\documentclass[11pt, a4paper]{article}

\usepackage{array}
\usepackage[portuguese]{babel}
\usepackage{cite}
\usepackage{float}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}

\chardef\_=`_

\title{\textbf{
    Sistemas Distribuídos -- Trabalho Prático  \\
    \large Base de dados concorrente com acesso remoto
}}
\author{
    \begin{tabular}{ll}
        Carolina Sofia Lopes Queirós Pereira  & A100836 \\
        Diogo Luís Barros Costa               & A100751 \\
        Humberto Gil Azevedo Sampaio Gomes    & A104348 \\
        Sara Azevedo Lopes                    & A104179
    \end{tabular}
}
\date{28 de dezembro de 2024}

\begin{document}

% Use rsvg-convert instead of direct EPS to get font embedding
\immediate\write18{neato -Tsvg dot/Architecture.dot | rsvg-convert -f eps -o dot/Architecture.eps -}

\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{0pt}
\def\arraystretch{1.5}

\maketitle

\begin{abstract}
    O trabalho prático proposto consiste no desenvolvimento de uma base de dados que armazena, em
    memória, associações chave-valor. A base de dados é gerida por um servidor, que serve pedidos de
    clientes comunicados via TCP/IP, garantido a atomicidade das suas execuções. Desenvolveu-se uma
    solução concorrente, utilizando primitivas de sincronização baseadas em monitores. Procurou-se
    diminuir a contenção e minimizar o número de \emph{threads} acordadas, pelo que se implementaram
    diversas estratégias de controlo de concorrência, procurando-se aumentar o desempenho do
    \emph{software} sem sacrificar a sua correção. O desempenho destas várias estratégias foi
    medido com recurso a uma ferramenta de testes também desenvolvida, e os resultados dos
    \emph{benchmarks} realizados apresentam-se neste relatório.
\end{abstract}

\section{Arquitetura do programa}

O \emph{software} desenvolvido foi dividido em componentes, que se apresentam na figura abaixo,
juntamente com as dependências entre si:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{dot/Architecture.eps}
    \caption{Dependências entre os vários componentes da solução desenvolvida.}
    \label{architecture}
\end{figure}

A maioria da funcionalidade do \emph{software} está localizada nas bibliotecas \texttt{common} e
\texttt{libserver}:

\begin{itemize}
    \item \texttt{common}
    \begin{itemize}
        \item Mensagens do protocolo de comunicação entre \texttt{client} e \texttt{server}, e a sua
            serialização e deserialização;

        \item Lógica de comunicação do cliente.
    \end{itemize}

    \item \texttt{libserver}
    \begin{itemize}
        \item Várias implementações da estrutura de armazenamento de dados (\emph{backends}), com
            estratégias de controlo de concorrência distintas.

        \item Lógica de comunicação do servidor.
    \end{itemize}
\end{itemize}

Os programas \texttt{client} e \texttt{server} não passam de \emph{wrappers} à volta das bibliotecas
\texttt{common} e \texttt{libserver}, respetivamente. No programa \texttt{tester}, é implementada
uma \emph{framework} para \emph{benchmarking} tanto dos \emph{backends} em \texttt{libserver} como
da base de dados completa.

\section{\emph{Backends} implementados}

\subsection{\texttt{SimpleHashMapBackend}}

Este \emph{backend} consiste numa tabela de \emph{hash} que armazena as associações, e cujo acesso
concorrente é moderado por um \emph{lock} de leitores e escritores. Há também duas variáveis de
condição (associadas ao \emph{lock} de escritores), uma notificada quando os conteúdos da base de
dados são alterados, e outra quando todas as operações \texttt{getWhen} terminam de verificar se a
sua condição é verdadeira.

A operação \texttt{getWhen} é a mais complexa: após adquirir o \emph{lock} para escritas, regista-se
a \emph{thread} atual como estando à espera de uma atualização, e espera-se na variável de condição
associada a atualizações da base de dados. As operações \texttt{put} e \texttt{multiPut}, quando
terminam, sinalizam as \emph{threads} à espera desta variável de condição (caso as haja). As
\emph{threads} na operação \texttt{getWhen} podem, caso se verifique a sua condição, remover-se da
lista de \emph{threads} à espera e devolver um valor. Quando a última \emph{thread} a executar um
\texttt{getWhen} verifica a sua condição, sinaliza as \emph{threads} à espera do fim da execução das
operações \texttt{getWhen} (\emph{threads} no início das operações \texttt{put} e \texttt{multiPut}).

\subsection{\texttt{MultiConditionHashMapBackend}}

Este \emph{backend} é muito semelhante ao anterior, com a diferença de que são utilizadas mais
variáveis de condição relativas à alteração da base de dados, para uma maior granularidade na
sinalização de \emph{threads}. As operações \texttt{getWhen}, no seu início, criam, caso não exista,
uma variável de condição associada á atualização da sua chave, pela qual esperam, e as operações
\texttt{put} e \texttt{multiPut} sinalizam apenas as \emph{threads} à espera de variáveis de
condição associadas às chaves que modificam. A execução de uma operação \texttt{getWhen} também
exige a destruição de uma variável de condição caso não haja mais \emph{threads} dela dependentes.

Uma abordagem alternativa que evita a criação de novas variáveis de condição foi considerada. Esta
envolve a criação inicial de $N$ variáveis de condição, às quais as chaves se associam pela sua
\emph{hash}. No entanto, testes empíricos demonstraram que esta solução apresenta um desempenho
semelhante à abordagem com criação de novas variáveis de condição, não se justificando alterações ao
\emph{backend}.

\subsection{\texttt{ShardedHashMapBackend}}

Este \emph{backend} consiste no uso de $N$ tabelas de \emph{hash} (\emph{shards}), associadas a $N$
\emph{locks} de leitores e escritores. A \emph{hash} de uma chave determina o \emph{shard} onde será
armazenada. As operações \texttt{get} e \texttt{put} precisam de adquirir apenas um \emph{lock}, e
as operações \texttt{multiGet} e \texttt{multiPut} precisam de adquirir vários \emph{locks},
fazendo-o ordenadamente para evitar \emph{deadlocks}, e usado \emph{two-phase locking} para diminuir
o tempo que cada \emph{lock} se encontra adquirido.

Não foi possível implementar a operação \texttt{getWhen} neste \emph{backend} sem prejudicar
gravemente o seu desempenho, pelo que esta não foi implementada. Uma operação de escrita precisa de
garantir que nada é escrito na base de dados que influencie o resultado das operações
\texttt{getWhen} a processar, podendo fazê-lo com a aquisição dos \emph{locks} associados aos
\emph{shards} das chaves necessárias. No entanto, para conhecer os \emph{locks} que deve adquirir,
teria, em primeiro lugar, de adquirir os \emph{locks} associados às chaves a escrever, e adquirir
outros \emph{locks} posteriormente poderia causar a violação da ordenação da aquisição de
\emph{locks}, conduzindo a uma possível situação de \emph{deadlock}. Este problema poderia ter sido
resolvido com um \emph{lock} ao nível da coleção, mas testes empíricos mostraram que o seu uso fazia
com que este \emph{backend} tivesse um desempenho semelhante aos \emph{backends} de \emph{lock}
único apresentados.

\section{Protocolo de comunicação entre \texttt{client} e \texttt{server}}

\pagebreak % TODO - remover depois de escrever parte anterior
\section{\emph{Framework} de testes}

\subsection{Funcionalidade e implementação}

Foi desenvolvida uma \emph{framework} para testes de desempenho da base de dados. Um teste de
desempenho começa com a criação de uma base de dados e um povoamento inicial. Depois, são criadas
várias \emph{threads}, e cada uma gera operações de leitura e escrita aleatoriamente, executando-as
e medindo o tempo de execução de cada uma. Estes tempos são utilizados para o cálculo da média e do
desvio padrão do tempo de execução de cada tipo de operação. O número total de operações a executar
é dividido em blocos, que são dinamicamente distribuídos pelas \emph{threads}. O teste termina
quando o número o conjunto de \emph{threads} completa um número predeterminado de operações.

A principal dificuldade na implementação da \emph{framework} relacionou-se com a operação
\texttt{getWhen}, que bloqueia até uma condição se verificar na base de dados. É possível que todas
as \emph{threads} bloqueiem, e não haja nenhuma \emph{thread} disponível para desbloquear as
\emph{threads} bloqueadas. Para resolver este problema, é criada uma \emph{thread} no início de cada
teste, responsável por desbloquear \emph{threads} bloqueadas em operações \texttt{getWhen}. Antes de
uma \emph{thread} executar uma operação \texttt{getWhen}, atualiza uma variável que armazena a
condição na qual irá bloquear. A \emph{thread} de desbloqueio itera constantemente por estas
condições, atualizando a base de dados de modo a desbloquear outras \emph{threads}. Assim, não faz
sentido que a \emph{framework} de testes meça o tempo médio de execução de operações
\texttt{getWhen}, visto que este está altamente dependente de quando a \emph{thread} de desbloqueio
é escalonada, refletindo fracamente o desempenho da base de dados.

Outra possibilidade de resolução deste problema menos computacionalmente intensiva consiste na
existência de uma (ou várias) \emph{threads} responsáveis pela geração das operações, que garantem
que todas as operações \texttt{getWhen} são correspondidas por uma operação de escrita posterior que
desbloqueia a \emph{thread} a executar o \texttt{getWhen}. No entanto, esta estratégia pode exigir o
uso de blocos muito pequenos para assegurar que uma dada fração das operações sejam do tipo
\texttt{getWhen}, aumentando o \emph{overhead} do controlo de concorrência, e possivelmente
impedindo a \emph{framework} de testes de medir o desempenho máximo da base de dados.

Por último, foram três as bibliotecas utilizadas para auxiliar o desenvolvimento da \emph{framework}
de testes. Para implementações de distribuições numéricas (uniforme, Zipf, \ldots), a biblioteca
Apache Commons Math \cite{apache-commons-math} foi utilizada, e as bibliotecas JFreeChart
\cite{jfreechart} e Apache XML Graphics \cite{apache-xml-graphics} foram utilizadas para a geração
automática dos gráficos apresentados neste documento.

\subsection{Metodologia de testagem e resultados}

Procurou-se testar o desempenho da base de dados desenvolvida em diversos cenários. Para isso,
tirou-se proveito do elevadíssimo grau de configurabilidade da \emph{framework} de testes
desenvolvida, e foram concebidos diferentes \emph{benchmarks}, descritos no anexo
\ref{benckmark-description}, e executados num ambiente de execução descrito no anexo
\ref{hardware-software-description}.

\section{Conclusão}

\section{Bibliografia}
\def\refname{}
\vspace{-1.5cm}
\begin{thebibliography}{9}
    \bibitem{apache-commons-math}
        The Apache Software Foundation. "Commons Math: The Apache Commons Mathematics Library."{},
        Apache Commons. Accessed: Dec. 20, 2024. [Online.] Available:
        \url{https://commons.apache.org/proper/commons-math/}

    \bibitem{jfreechart}
        D. Gilbert. "Welcome To JFreeChart!."{}, JFreeChart. Accessed: Dec. 20, 2024. [Online.]
        Available: \url{https://www.jfree.org/jfreechart/}

    \bibitem{apache-xml-graphics}
        The Apache Software Foundation. "Apache FOP."{} The Apache XML Graphics Project. Accessed:
        Dec. 20, 2024. [Online.] Available: \url{https://xmlgraphics.apache.org/fop/}
\end{thebibliography}

\section{Anexos}

\subsection{Características do \emph{benchmarks}}
\label{benckmark-description}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|p{5cm}|c|c|c|}
            \hline & Maioritariamente leituras & Equilibrado & Equilibrado c/ \texttt{getWhen} \\

            \hline Número de chaves         & \multicolumn{3}{c|}{128}          \\
            \hline Número de valores        & \multicolumn{3}{c|}{128}          \\
            \hline Comprimento de uma chave & \multicolumn{3}{c|}{8 caracteres} \\
            \hline Comprimento de um valor  & \multicolumn{3}{c|}{8 octetos}    \\

            \hline Percentagem de \texttt{put}s      & 5  & 25 & 25 \\
            \hline Percentagem de \texttt{get}s      & 70 & 25 & 20 \\
            \hline Percentagem de \texttt{multiPut}s & 0  & 25 & 25 \\
            \hline Percentagem de \texttt{multiGet}s & 25 & 25 & 25 \\
            \hline Percentagem de \texttt{getWhen}s  & 0  & 0  & 5  \\

            \hline Distribuição de chaves  & \multicolumn{3}{c|}{Uniforme} \\
            \hline Distribuição de valores & \multicolumn{3}{c|}{Uniforme} \\
            \hline Distribuição de número de chaves em operações multi &
                \multicolumn{3}{c|}{Uniforme entre 2 e 4, inclusive} \\

            \hline Número de operações & \multicolumn{2}{c|}{8 milhões} & 1 milhão\footnotemark \\
            \hline Tamanho de um bloco & \multicolumn{3}{c|}{4096} \\
            \hline
        \end{tabular}
    \end{center}

    \caption{Características dos \emph{benchmarks} concebidos.}
\end{table}

\footnotetext{
    Devido à \emph{thread} de desbloqueio de operações \texttt{getWhen}, o teste seria muito
    demorado caso fossem executadas 8 milhões de operações.
}

Os três \emph{backends} são testados, sendo que o \texttt{ShardedHashMapBackend} é inicializado com
64 \emph{shards} e não é sujeito ao \emph{benchmark} "Equilibrado c/ \texttt{getWhen}"{}.

\subsection{\emph{Hardware} e \emph{software} utilizados para a execução dos \emph{benchmarks}}
\label{hardware-software-description}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline Processador       & Intel Core i3-7100 3.9 GHz  \\
            \hline Memória           & 8 GiB DDR4 2400 MT/s        \\
            \hline Sistema Operativo & Linux 6.11.5                \\
            \hline JRE               & OpenJDK 21.0.5              \\
            \hline
        \end{tabular}
    \end{center}

    \caption{\emph{Hardware} e \emph{software} utilizados para a execução dos \emph{benchmarks}.}
    \label{hardware-software}
\end{table}

\end{document}
