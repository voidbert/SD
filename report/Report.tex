\documentclass[11pt, a4paper]{article}

\usepackage{array}
\usepackage[portuguese]{babel}
\usepackage{cite}
\usepackage{float}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}

\chardef\_=`_

\title{\textbf{
    Sistemas Distribuídos -- Trabalho Prático  \\
    \large Base de dados concorrente com acesso remoto
}}
\author{
    \begin{tabular}{ll}
        Carolina Sofia Lopes Queirós Pereira  & A100836 \\
        Diogo Luís Barros Costa               & A100751 \\
        Humberto Gil Azevedo Sampaio Gomes    & A104348 \\
        Sara Azevedo Lopes                    & A104179
    \end{tabular}
}
\date{28 de dezembro de 2024}

\begin{document}

% Use rsvg-convert instead of direct EPS to get font embedding
\immediate\write18{neato -Tsvg dot/Architecture.dot | rsvg-convert -f eps -o dot/Architecture.eps -}

\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{0pt}
\def\arraystretch{1.5}

\maketitle

\begin{abstract}
    O trabalho prático proposto consiste no desenvolvimento de uma base de dados que armazena, em
    memória, associações chave-valor. A base de dados é gerida por um servidor, que serve pedidos de
    clientes comunicados via TCP/IP, garantido a atomicidade das suas execuções. Desenvolveu-se uma
    solução concorrente, utilizando primitivas de sincronização baseadas em monitores. Procurou-se
    diminuir a contenção e minimizar o número de \emph{threads} acordadas, pelo que se implementaram
    diversas estratégias de controlo de concorrência, procurando-se aumentar o desempenho do
    \emph{software} sem sacrificar a sua correção. O desempenho destas várias estratégias foi
    medido com recurso a uma ferramenta de testes também desenvolvida, e os resultados dos
    \emph{benchmarks} realizados apresentam-se neste relatório.
\end{abstract}

\section{Arquitetura do programa}

O \emph{software} desenvolvido foi dividido em componentes, que se apresentam na figura abaixo,
juntamente com as dependências entre si:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{dot/Architecture.eps}
    \caption{Dependências entre os vários componentes da solução desenvolvida.}
    \label{architecture}
\end{figure}

A maioria da funcionalidade do \emph{software} está localizada nas bibliotecas \texttt{common} e
\texttt{libserver}:

\begin{itemize}
    \item \texttt{common}
    \begin{itemize}
        \item Mensagens do protocolo de comunicação entre \texttt{client} e \texttt{server}, e a sua
            serialização e deserialização;

        \item Lógica de comunicação do cliente.
    \end{itemize}

    \item \texttt{libserver}
    \begin{itemize}
        \item Várias implementações da estrutura de armazenamento de dados (\emph{backends}), com
            estratégias de controlo de concorrência distintas.

        \item Lógica de comunicação do servidor.
    \end{itemize}
\end{itemize}

Os programas \texttt{client} e \texttt{server} não passam de \emph{wrappers} à volta das bibliotecas
\texttt{common} e \texttt{libserver}, respetivamente. No programa \texttt{tester}, é implementada
uma \emph{framework} para \emph{benchmarking} tanto dos \emph{backends} em \texttt{libserver} como
da base de dados completa.

\section{\emph{Backends} implementados}

\subsection{\emph{Backends} baseados num único \emph{lock}}

\subsubsection{\texttt{SimpleHashMapBackend}}

\subsubsection{\texttt{MultiConditionHashMapBackend}}

\subsection{\emph{Backend} com \emph{sharding} (\texttt{ShardedHashMapBackend})}

\section{Protocolo de comunicação entre \texttt{client} e \texttt{server}}

\pagebreak % TODO - remover depois de escrever parte anterior
\section{\emph{Framework} de testes}

\subsection{Funcionalidade e implementação}

Foi desenvolvida uma \emph{framework} para testes de desempenho da base de dados. Um teste de
desempenho começa com a criação de uma base de dados e um povoamento inicial. Depois, são criadas
várias \emph{threads}, e cada uma gera operações de leitura e escrita aleatoriamente, executando-as
e medindo o tempo de execução de cada uma. Estes tempos são utilizados para o cálculo da média e do
desvio padrão do tempo de execução de cada tipo de operação. O número total de operações a executar
é dividido em blocos, que são dinamicamente distribuídos pelas \emph{threads}. O teste termina
quando o número o conjunto de \emph{threads} completa um número predeterminado de operações.

A principal dificuldade na implementação da \emph{framework} relacionou-se com a operação
\texttt{getWhen}, que bloqueia até uma condição se verificar na base de dados. É possível que todas
as \emph{threads} bloqueiem, e não haja nenhuma \emph{thread} disponível para desbloquear as
\emph{threads} bloqueadas. Para resolver este problema, é criada uma \emph{thread} no início de cada
teste, responsável por desbloquear \emph{threads} bloqueadas em operações \texttt{getWhen}. Antes de
uma \emph{thread} executar uma operação \texttt{getWhen}, atualiza uma variável que armazena a
condição na qual irá bloquear. A \emph{thread} de desbloqueio itera constantemente por estas
condições, atualizando a base de dados de modo a desbloquear outras \emph{threads}. Assim, não faz
sentido que a \emph{framework} de testes meça o tempo médio de execução de operações
\texttt{getWhen}, visto que este está altamente dependente de quando a \emph{thread} de desbloqueio
é escalonada, refletindo fracamente o desempenho da base de dados.

Outra possibilidade de resolução deste problema menos computacionalmente intensiva consiste na
existência de uma (ou várias) \emph{threads} responsáveis pela geração das operações, que garantem
que todas as operações \texttt{getWhen} são correspondidas por uma operação de escrita posterior que
desbloqueia a \emph{thread} a executar o \texttt{getWhen}. No entanto, esta estratégia pode exigir o
uso de blocos muito pequenos para assegurar que uma dada fração das operações sejam do tipo
\texttt{getWhen}, aumentando o \emph{overhead} do controlo de concorrência, e possivelmente
impedindo a \emph{framework} de testes de medir o desempenho máximo da base de dados.

Por último, foram três as bibliotecas utilizadas para auxiliar o desenvolvimento da \emph{framework}
de testes. Para implementações de distribuições numéricas (uniforme, Zipf, \ldots), a biblioteca
Apache Commons Math \cite{apache-commons-math} foi utilizada, e as bibliotecas JFreeChart
\cite{jfreechart} e Apache XML Graphics \cite{apache-xml-graphics} foram utilizadas para a geração
automática dos gráficos apresentados neste documento.

\subsection{Metodologia de testagem e resultados}

Procurou-se testar o desempenho da base de dados desenvolvida em diversos cenários. Para isso,
tirou-se proveito do elevadíssimo grau de configurabilidade da \emph{framework} de testes
desenvolvida, e foram concebidos diferentes \emph{benchmarks}, descritos no anexo
\ref{benckmark-description}, e executados num ambiente de execução descrito no anexo
\ref{hardware-software-description}.

\section{Conclusão}

\section{Bibliografia}
\def\refname{}
\vspace{-1.5cm}
\begin{thebibliography}{9}
    \bibitem{apache-commons-math}
        The Apache Software Foundation. "Commons Math: The Apache Commons Mathematics Library."{},
        Apache Commons. Accessed: Dec. 20, 2024. [Online.] Available:
        \url{https://commons.apache.org/proper/commons-math/}

    \bibitem{jfreechart}
        D. Gilbert. "Welcome To JFreeChart!."{}, JFreeChart. Accessed: Dec. 20, 2024. [Online.]
        Available: \url{https://www.jfree.org/jfreechart/}

    \bibitem{apache-xml-graphics}
        The Apache Software Foundation. "Apache FOP."{} The Apache XML Graphics Project. Accessed:
        Dec. 20, 2024. [Online.] Available: \url{https://xmlgraphics.apache.org/fop/}
\end{thebibliography}

\section{Anexos}

\subsection{Características do \emph{benchmarks}}
\label{benckmark-description}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|p{5cm}|c|c|c|}
            \hline & Maioritariamente leituras & Equilibrado & Equilibrado c/ \texttt{getWhen} \\

            \hline Número de chaves         & \multicolumn{3}{c|}{128}          \\
            \hline Número de valores        & \multicolumn{3}{c|}{128}          \\
            \hline Comprimento de uma chave & \multicolumn{3}{c|}{8 caracteres} \\
            \hline Comprimento de um valor  & \multicolumn{3}{c|}{8 octetos}    \\

            \hline Percentagem de \texttt{put}s      & 5  & 25 & 25 \\
            \hline Percentagem de \texttt{get}s      & 70 & 25 & 20 \\
            \hline Percentagem de \texttt{multiPut}s & 0  & 25 & 25 \\
            \hline Percentagem de \texttt{multiGet}s & 25 & 25 & 25 \\
            \hline Percentagem de \texttt{getWhen}s  & 0  & 0  & 5  \\

            \hline Distribuição de chaves  & \multicolumn{3}{c|}{Uniforme} \\
            \hline Distribuição de valores & \multicolumn{3}{c|}{Uniforme} \\
            \hline Distribuição de número de chaves em operações multi &
                \multicolumn{3}{c|}{Uniforme entre 2 e 4, inclusive} \\

            \hline Número de operações & \multicolumn{2}{c|}{8 milhões} & 1 milhão\footnotemark \\
            \hline Tamanho de um bloco & \multicolumn{3}{c|}{4096} \\
            \hline
        \end{tabular}
    \end{center}

    \caption{Características dos \emph{benchmarks} concebidos.}
\end{table}

\footnotetext{
    Devido à \emph{thread} de desbloqueio de operações \texttt{getWhen}, o teste seria muito
    demorado caso fossem executadas 8 milhões de operações.
}

Os três \emph{backends} são testados, sendo que o \texttt{ShardedHashMapBackend} é inicializado com
64 \emph{shards} e não é sujeito ao \emph{benchmark} "Equilibrado c/ \texttt{getWhen}"{}.

\subsection{\emph{Hardware} e \emph{software} utilizados para a execução dos \emph{benchmarks}}
\label{hardware-software-description}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline Processador       & Intel Core i3-7100 3.9 GHz  \\
            \hline Memória           & 8 GiB DDR4 2400 MT/s        \\
            \hline Sistema Operativo & Linux 6.11.5                \\
            \hline JRE               & OpenJDK 21.0.5              \\
            \hline
        \end{tabular}
    \end{center}

    \caption{\emph{Hardware} e \emph{software} utilizados para a execução dos \emph{benchmarks}.}
    \label{hardware-software}
\end{table}

\end{document}
